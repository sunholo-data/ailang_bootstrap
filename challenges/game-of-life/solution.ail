-- Conway's Game of Life - AILANG-Computed Animation
--
-- This is the REAL deal: AILANG computes every generation,
-- then outputs an HTML file that animates the pre-computed frames.
-- All Game of Life logic runs in AILANG, not JavaScript.
--
-- Usage:
--   ailang run --relax-modules --caps IO,FS --entry main examples/game_of_life_real.ail

module game_of_life_real

import std/array (make as arrayMake, get as arrayGet, set as arraySet)
import std/io (println)
import std/fs (writeFile)

-- Cell state
type Cell = Alive | Dead

-- 15x15 grid for interesting patterns
pure func gridSize() -> int { 15 }
pure func gridTotal() -> int { 225 }

pure func toIndex(x: int, y: int) -> int { y * gridSize() + x }

pure func inBounds(x: int, y: int) -> bool {
    x >= 0 && x < gridSize() && y >= 0 && y < gridSize()
}

pure func getCell(grid: Array[Cell], x: int, y: int) -> Cell {
    if inBounds(x, y) then arrayGet(grid, toIndex(x, y)) else Dead
}

pure func cellValue(cell: Cell) -> int {
    match cell { Alive => 1, Dead => 0 }
}

-- Count all 8 neighbors
pure func countNeighbors(grid: Array[Cell], x: int, y: int) -> int {
    cellValue(getCell(grid, x - 1, y - 1)) +
    cellValue(getCell(grid, x,     y - 1)) +
    cellValue(getCell(grid, x + 1, y - 1)) +
    cellValue(getCell(grid, x - 1, y)) +
    cellValue(getCell(grid, x + 1, y)) +
    cellValue(getCell(grid, x - 1, y + 1)) +
    cellValue(getCell(grid, x,     y + 1)) +
    cellValue(getCell(grid, x + 1, y + 1))
}

-- Conway's rules: 2-3 neighbors to survive, exactly 3 to be born
pure func shouldLive(isAlive: int, neighbors: int) -> int {
    if isAlive == 1 then
        if neighbors == 2 || neighbors == 3 then 1 else 0
    else
        if neighbors == 3 then 1 else 0
}

pure func emptyGrid() -> Array[Cell] { arrayMake(gridTotal(), Dead) }

pure func setCell(grid: Array[Cell], x: int, y: int, v: Cell) -> Array[Cell] {
    if inBounds(x, y) then arraySet(grid, toIndex(x, y), v) else grid
}

pure func nextCell(grid: Array[Cell], x: int, y: int) -> Cell {
    let c = cellValue(getCell(grid, x, y));
    let n = countNeighbors(grid, x, y);
    if shouldLive(c, n) == 1 then Alive else Dead
}

-- Update one row
pure func updateRow(old: Array[Cell], new: Array[Cell], y: int) -> Array[Cell] {
    let g0 = setCell(new, 0, y, nextCell(old, 0, y));
    let g1 = setCell(g0, 1, y, nextCell(old, 1, y));
    let g2 = setCell(g1, 2, y, nextCell(old, 2, y));
    let g3 = setCell(g2, 3, y, nextCell(old, 3, y));
    let g4 = setCell(g3, 4, y, nextCell(old, 4, y));
    let g5 = setCell(g4, 5, y, nextCell(old, 5, y));
    let g6 = setCell(g5, 6, y, nextCell(old, 6, y));
    let g7 = setCell(g6, 7, y, nextCell(old, 7, y));
    let g8 = setCell(g7, 8, y, nextCell(old, 8, y));
    let g9 = setCell(g8, 9, y, nextCell(old, 9, y));
    let g10 = setCell(g9, 10, y, nextCell(old, 10, y));
    let g11 = setCell(g10, 11, y, nextCell(old, 11, y));
    let g12 = setCell(g11, 12, y, nextCell(old, 12, y));
    let g13 = setCell(g12, 13, y, nextCell(old, 13, y));
    setCell(g13, 14, y, nextCell(old, 14, y))
}

-- Compute next generation - THIS IS THE AILANG GAME OF LIFE LOGIC
pure func nextGeneration(grid: Array[Cell]) -> Array[Cell] {
    let g = emptyGrid();
    let r0 = updateRow(grid, g, 0);
    let r1 = updateRow(grid, r0, 1);
    let r2 = updateRow(grid, r1, 2);
    let r3 = updateRow(grid, r2, 3);
    let r4 = updateRow(grid, r3, 4);
    let r5 = updateRow(grid, r4, 5);
    let r6 = updateRow(grid, r5, 6);
    let r7 = updateRow(grid, r6, 7);
    let r8 = updateRow(grid, r7, 8);
    let r9 = updateRow(grid, r8, 9);
    let r10 = updateRow(grid, r9, 10);
    let r11 = updateRow(grid, r10, 11);
    let r12 = updateRow(grid, r11, 12);
    let r13 = updateRow(grid, r12, 13);
    updateRow(grid, r13, 14)
}

-- R-pentomino: chaotic pattern that evolves for 1103 generations
pure func makeRPentomino() -> Array[Cell] {
    let g = emptyGrid();
    let g1 = setCell(g, 7, 6, Alive);
    let g2 = setCell(g1, 8, 6, Alive);
    let g3 = setCell(g2, 6, 7, Alive);
    let g4 = setCell(g3, 7, 7, Alive);
    setCell(g4, 7, 8, Alive)
}

-- Serialize one cell to "0" or "1"
pure func cellToChar(cell: Cell) -> string {
    match cell { Alive => "1", Dead => "0" }
}

-- Serialize a row to a string of 0s and 1s
pure func serializeRow(grid: Array[Cell], y: int) -> string {
    cellToChar(getCell(grid, 0, y)) ++
    cellToChar(getCell(grid, 1, y)) ++
    cellToChar(getCell(grid, 2, y)) ++
    cellToChar(getCell(grid, 3, y)) ++
    cellToChar(getCell(grid, 4, y)) ++
    cellToChar(getCell(grid, 5, y)) ++
    cellToChar(getCell(grid, 6, y)) ++
    cellToChar(getCell(grid, 7, y)) ++
    cellToChar(getCell(grid, 8, y)) ++
    cellToChar(getCell(grid, 9, y)) ++
    cellToChar(getCell(grid, 10, y)) ++
    cellToChar(getCell(grid, 11, y)) ++
    cellToChar(getCell(grid, 12, y)) ++
    cellToChar(getCell(grid, 13, y)) ++
    cellToChar(getCell(grid, 14, y))
}

-- Serialize entire grid to a single string
pure func serializeGrid(grid: Array[Cell]) -> string {
    serializeRow(grid, 0) ++
    serializeRow(grid, 1) ++
    serializeRow(grid, 2) ++
    serializeRow(grid, 3) ++
    serializeRow(grid, 4) ++
    serializeRow(grid, 5) ++
    serializeRow(grid, 6) ++
    serializeRow(grid, 7) ++
    serializeRow(grid, 8) ++
    serializeRow(grid, 9) ++
    serializeRow(grid, 10) ++
    serializeRow(grid, 11) ++
    serializeRow(grid, 12) ++
    serializeRow(grid, 13) ++
    serializeRow(grid, 14)
}

-- Compute 60 generations and serialize each
pure func computeFrames(grid: Array[Cell], n: int, acc: string) -> string {
    if n <= 0 then acc
    else {
        let next = nextGeneration(grid);
        let frame = "\"" ++ serializeGrid(next) ++ "\"";
        let newAcc = if acc == "" then frame else acc ++ "," ++ frame;
        computeFrames(next, n - 1, newAcc)
    }
}

-- Build the complete HTML with AILANG-computed frames embedded
func buildHTML(frames: string) -> string {
"<!DOCTYPE html>
<html>
<head>
  <title>AILANG Game of Life - Computed in AILANG</title>
  <style>
    body {
      background: #0a0a1a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      font-family: monospace;
      color: #fff;
    }
    h1 { color: #0f0; margin-bottom: 0.25em; }
    .note { color: #888; font-size: 0.9em; margin-bottom: 1em; }
    canvas { border: 2px solid #0f0; }
    .info { margin-top: 1em; color: #0f0; font-size: 1.2em; }
    .footer { margin-top: 2em; color: #444; font-size: 0.8em; }
    .highlight { color: #ff0; }
  </style>
</head>
<body>
  <h1>Conway's Game of Life</h1>
  <p class=\"note\">All 60 frames <span class=\"highlight\">computed by AILANG</span>, not JavaScript</p>
  <canvas id=\"c\" width=\"450\" height=\"450\"></canvas>
  <div class=\"info\">Generation: <span id=\"gen\">0</span></div>
  <p class=\"footer\">R-pentomino pattern - computed with AILANG's effect system, arrays, and pattern matching</p>
  <script>
    // These frames were PRE-COMPUTED by AILANG's Game of Life implementation
    const frames = [" ++ frames ++ "];
    const SIZE = 15;
    const CELL = 30;
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let frame = 0;

    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, 450, 450);
      const data = frames[frame];
      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (data[y * SIZE + x] === '1') {
            const hue = (frame * 5 + x * 10 + y * 10) % 360;
            ctx.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
            ctx.fillRect(x * CELL + 2, y * CELL + 2, CELL - 4, CELL - 4);
          }
        }
      }
      document.getElementById('gen').textContent = frame;
      frame = (frame + 1) % frames.length;
    }
    setInterval(draw, 150);
    draw();
  </script>
</body>
</html>"
}

export func main() -> () ! {IO, FS} {
    println("AILANG Game of Life - Real Computation Demo");
    println("============================================");
    println("");
    println("Computing 60 generations using AILANG...");

    -- Start with R-pentomino
    let initial = makeRPentomino();
    let firstFrame = "\"" ++ serializeGrid(initial) ++ "\"";

    -- AILANG computes all 60 generations here!
    println("  - Using AILANG arrays and pure functions");
    println("  - Applying Conway's rules via pattern matching");
    println("  - Each generation computed by nextGeneration()");

    let allFrames = firstFrame ++ "," ++ computeFrames(initial, 59, "");

    println("");
    println("Writing HTML visualization...");
    let html = buildHTML(allFrames);
    writeFile("game_of_life_computed.html", html);

    println("");
    println("Done! Open game_of_life_computed.html");
    println("");
    println("The HTML just DISPLAYS what AILANG computed.");
    println("All Game of Life logic ran in AILANG, not JavaScript.")
}
